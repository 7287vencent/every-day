### 题目 501. 二叉搜索树中的众数
#### 题目描述
给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树
例如：
```js
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2
返回[2].
```

- 提示：如果众数超过1个，不需考虑输出顺序

- 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

### 解题思路
#### 方法一：中序递归
我们可以顺序扫描中序遍历序列，用 `base` 记录当前的数字，用 `count` 记录当前数字重复的次数，用 `maxCount` 来维护已经扫描过的数当中出现最多的那个数字的出现次数，用 `answer` 数组记录出现的众数。每次扫描到一个新的元素：

- 首先更新 `base` 和 `count`:
  - 如果该元素和 `base` 相等，那么 `count` 自增 `1`；
  - 否则将 `base` 更新为当前数字，`count` 复位为 `1`。
- 然后更新 `maxCount`：
  - 如果 `count=maxCount`，那么说明当前的这个数字（`base`）出现的次数等于当前众数出现的次数，将 `base` 加入 `answer` 数组；
  - 如果 `count>maxCount`，那么说明当前的这个数字（`base`）出现的次数大于当前众数出现的次数，因此，我们需要将 `maxCount` 更新为 `count`，清空 `answer` 数组后将 `base` 加入 `answer` 数组。
  
我们可以把这个过程写成一个 `update` 函数。这样我们在寻找出现次数最多的数字的时候就可以省去一个哈希表带来的空间消耗。