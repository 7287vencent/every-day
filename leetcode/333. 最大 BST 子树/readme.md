### 题目 333. 最大 BST 子树
#### 题目描述
给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小。其中，最大指的是子树节点数最多的。

**二叉搜索树（BST）**中的所有节点都具备以下属性：

- 左子树的值小于其父（根）节点的值。

- 右子树的值大于其父（根）节点的值。

**注意**:

- 子树必须包含其所有后代。
**进阶**:

- 你能想出 `O(n)` 时间复杂度的解法吗？
 

示例 1：

![img](333.jpeg)


```js
输入：root = [10,5,15,1,8,null,7]
输出：3
解释：本例中最大的 BST 子树是高亮显示的子树。返回值是子树的大小，即 3 。
```
示例 2：

```js
输入：root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1]
输出：2
```
 

提示：

- 树上节点数目的范围是 `[0, 104]`
- `-104 <= Node.val <= 104`
### 解题思路
[官方题解](https://leetcode-cn.com/problems/largest-bst-subtree/solution/zui-da-bst-zi-shu-by-leetcode-solution/)

一棵树如果是二叉搜索树，那么它的左右子树也必然是二叉搜索树，则对于一个节点为根的子树，如果我们已经知道了左右子树是不是二叉搜索树，以及左右子树的值的范围 `[l,r]` ，那么如果左右子树均为二叉搜索树，根据性质我们只要判断该节点的值是不是大于左子树的最大值和小于右子树的最小值即能推断出该节点为根的子树是不是二叉搜索树，而又因为我们已经拿到了左右子树的信息，所以这个推断只需要 `O(1)` 的时间复杂度，而方法一不复用信息的话判断一棵子树是不是二叉搜索树则需要 `O(n)` 的时间复杂度。
