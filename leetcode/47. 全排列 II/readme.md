### 题目 47. 全排列 II
#### 题目描述
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

 

示例 1：

```js
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```
示例 2：

```js
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```
 

提示：

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

### 解题思路
[官方题解](https://leetcode-cn.com/problems/permutations-ii/solution/quan-pai-lie-ii-by-leetcode-solution/)
#### 方法一：回溯 + 递归
- 与上题不同的是，添加了一个状态存储，数字是否填入
- 并且对nums进行了排序，防止填入重复的数字


**关键的判断条件**
要解决重复问题，我们只要设定一个规则，保证在填第 `idx` 个数的时候重复数字只会被填入一次即可。而在本题解中，我们选择对原数组排序，保证相同的数字都相邻，然后每次填入的数一定是这个数所在重复数集合中「从左往右第一个未被填过的数字」，即如下的判断条件：

```js
if (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1]) {
    continue;
}
```
这个判断条件保证了对于重复数的集合，一定是从左往右逐个填入的。

假设我们有 `3` 个重复数排完序后相邻，那么我们一定保证每次都是拿从左往右第一个未被填过的数字，即整个数组的状态其实是保证了 [未填入，未填入，未填入] 到 [填入，未填入，未填入]，再到 [填入，填入，未填入]，最后到 [填入，填入，填入] 的过程的，因此可以达到去重的目标。
