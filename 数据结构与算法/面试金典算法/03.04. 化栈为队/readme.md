## 题目 03.04. 化栈为队
实现一个MyQueue类，该类用两个栈来实现一个队列。


示例：

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false

说明：

你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。


### 解题思路
  **用栈实现队列**

**1、栈的特点**

栈的特点是先进后出，进出元素都是在同一端（栈顶）。

https://blog.csdn.net/ailunlee/article/details/85100514

入栈：

![img](./20181219163544978.png)

出栈：

![img](./201812191635453.png)

**2、队列的特点**

队列的特点是先进先出，出入元素是在不同的两端（队头和队尾）。

入队：

![img](./20181219163544976.png)

出队：

![img](./2018121916354510.png)

**3、两个栈实现队列**

我们拥有两个栈，可以让其中一个栈作为队列的入口，负责插入新元素；另一个栈作为队列的出口，负责移除老的元素。

![img](./20181219163544998.png)

队列的主要操作无非有两个：入队和出队。在模拟入队操作时，每一个新元素都被压入到栈A当中。

​     让元素1“入队”：

![img](./2018121916354523.png)

​     让元素2“入队”：

![img](https://img-blog.csdnimg.cn/2018121916354547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FpbHVubGVl,size_16,color_FFFFFF,t_70)

​     让元素3“入队”：

![img](./2018121916354586.png)

​     这时候，我们希望最先“入队”的元素1“出队”，需要怎么做呢？

​     让栈A中的所有元素按顺序出栈，再按照出栈顺序压入栈B。这样一来，元素从栈A弹出并压入栈B的顺序是3,2,1，和当初进入栈A的顺序1，2,3是相反的：

![img](./20181219163545100.png)

​     此时让元素1“出队”，也就是让元素1从栈B弹出：

![img](./20181219163545132.png)

​     让元素2“出队”：

![img](./20181219163545126.png)

​     如果这个时候又想做入队操作了呢？当有新元素入队时，重新把新元素压入栈A。

​     让元素4“入队”：

![img](./20181219163545148.png)

​     此时的出队操作仍然从栈B弹出元素。

​     让元素3“出队”：

![img](./20181219163545160.png)

​     这个时候栈B已经空了，如果再想出队怎么办呢？只要栈A还有元素就像刚才一样，把栈A元素弹出并压入栈B。

![img](./20181219163545189.png)

​     让元素4“出队”：

![img](./20181219163545218.png)

