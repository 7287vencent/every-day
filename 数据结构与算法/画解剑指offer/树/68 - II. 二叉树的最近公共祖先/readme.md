## 题目 68 - II. 二叉树的最近公共祖先
#### 题目描述
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

<img src="./binarytree.png"><img>

示例 1:

``` js
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```
示例  2:

``` js
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```
说明:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

### 解题思路
#### 思路
`标签：二叉树、DFS`
- 整体思路：
  - 祖先节点定义：当前节点的父节点，其父节点的父节点，只要当前节点在某一个节点的子树下，则可以称其为当前节点的祖先节点
  - 公共祖先定义：p、q 节点都在某一个节点的子树下或者其自身，则可以称其为 p、q 节点的公共祖先节点
  - 最近公共祖先定义：从祖先节点的定义可以知道，如果 x 节点是 p、q 节点的公共祖先，那么 x 节点的祖先节点也一定是 p、q 节点的公共祖先，则距离 p、q 个节点深度最小的为最近公共祖先，通常表现为 p、q 节点不在最近公共祖先的同一个子树上
  - 根据题意可知，所有的节点值唯一，则可以根据 p、q 节点不在最近公共祖先的同一个子树上的特征，进行深度优先遍历，找到结果 
- 时间复杂度：O(n)，空间复杂度：O(n)
#### 算法流程
1. 终止条件：
   - 当 root 节点为 null 时，说明到达叶子节点的下一层，直接返回 null 即可
   - 当 root 节点为 p 或 q 时，说明找到了对应的节点，返回 root 即可
2. 递归内容：
   - 递归左子树 root.left，得到左子树返回值 left
   - 递归右子树 root.right，得到右子树返回值 right
3. 返回值：
   - 当 left 和 right 都为 null 时，说明当前层 root 的左右子树不包含 p、q 节点，返回 null 即可
   - 当 left 为 null 且 right 不为 null 时，说明当前层 root 的左子树不包含 p、q 节点，右子树包含 p、q 节点，则返回右子树 right
   - 当 left 不为 null 且 right 为 null 时，说明当前层 root 的左子树包含 p、q 节点，右子树不包含 p、q 节点，则返回左子树 left
   - 当 left 和 right 都不为 null 时，说明当前层 root 的左右子树均包含 p、q 节点，返回 root 即可
